# Design-Pattern
##设计模式
##面向对象的核心特征
     封装、继承、多态
## 对象设计的基本原则 GRASP General Responsibility Assignment Software Principles
    1. Creator 创建者
    2. information Expert 信息专家
    3. Controller 控制器
    4. Low Couping 低耦合
    5. High Cohesion 高内聚
    6. PolyMorphism 多态
    7. Pure Fabrication 纯虚构
    8. Indirection 间接
    9. Protected Variations 隔离变化
    其他：
        1. 开闭原则
        2. 能用组合的地方，不要用继承
        3. 依赖倒置原则DIP
### Creator 创建者
#### 解决的问题：
    当我们需要一个新的对象时，由谁来负责创建某个类的新实例
#### 解决方式：
    用class B 创建 class A 的实例，如果满足以下条件：

      1. B "包含" 或复合聚合 A
      2. B 记录 A 无论A做了什么，B都记录下来
      3. B和A的关系很密切
      4. B 具有 A 的初始化数据, 这些数据将在创建时传递给 A (B 是与 A 有关的专家)

### information Expert 信息专家
#### 解决的问题：
    将责任分配给对象的一般原则是什么
#### 解决方式：
    将责任分配给具有履行责任所需信息的类
    
    Information：实际上是一种认知职责
        对象拥有状态
        对象知道周围其他对象拥有的状态
        对象可以派生的信息
    解决步骤：
        明确说明责任
        相关类的设计模型中的查找
        如果不满足上述条件，再到域模型中的其他外观并创建设计类
#### 优点：
    封装性 Encapsulation
        对象充分利用自身的信息
        低耦合：对象单独就能完成，不需要其他对象
    系统行为分布到不同的类
        支持高内聚
### Low Couping 低耦合
    如何保证设计方案支持低的依赖性、低的变化影响度、增加可重用性？
##### 耦合的定义
    耦合: 一个元素与其它元素的联接、感知以及依赖程度的度量
##### 比较
    内聚: 模块内的操作之间联系紧密的程度
    耦合: 两个子模块之间联系的强度
##### 高耦合带来的问题
    牵一发动全身
        A依赖B，A与B之间有耦合，一旦B变化了，A就会受影响
    元素孤立是无法理解
    元素很难重用
### Controller 控制器
##### 解决的问题：
    在领域层，由谁负责首先接收并协调来自UI层的系统操作？
##### 解决的方式：
    将责任分配给表示以下选项之一的类:
        
        外观控制器：
            表示整个系统、根对象、在其中运行的对象或主要子系统
            为子系统中的一组接口提供一个一致的界面
            整体物理单元的抽象
            整个软件系统
            抽象其他一些整体系统或子系统的概念
            
            适用于：
                相对较小的系统
                有限数量的系统操作
                在消息处理系统中，不能转发消息到可选的控制器时
                
        会话控制器（用例控制器）：
            一种纯虚构出来的概念 Pure Fabrication，即领域模型中没有的概念
            表示系统事件发生的用例场景
            
            应用场合：
                当采用外观控制器会导致高耦合、低内聚时
                很多系统事件跨越多个不同的处理过程
                概念上容易理解和构建
                    一个会话控制器负责一类系统事件
             
             命名规律：
                <UseCaseName> Handler
                <UseCaseName> CoOrdinator
                <UseCaseName>Session
                
        当系统事件不是太多时，一般用外观控制器，当系统事件很多和用例相关的又分为好几组，
        建议每一组定义一个handler（会话控制器）
##### 委托模式：
    外部输入事件可以来自参与者（人）或者（其他系统）
    Facade — 相当于领域层对外部世界的“脸”
        Register
    Handler —处理系统某个明确的功能集，比如相关的一组系统事件
        XXXHandler
##### Discuss: Controller vs. UI
    1）UI层不应负责处 理系统操作 
    2）系统操作一定在 领域层进行处理 本书把应用逻辑层 又称为架构的领域层 
    3）控制器负责委托 （转发）消息 
    4）较差的设计方案：业务逻辑嵌 入到展示层
#####  Discuss: Controller — Benefits（优势） 
    容易适应UI层的变化 
    领域层代码易于重用（因为UI层一般与应用关系密切）
    有助于保证应用所需要的操作顺序
    可以对系统的状态进行推理（UI层不保存系统状态
##### Bloated(臃肿的) Controllers 
    当一个外观控制器处理了大部分系统事件时
    当一个控制器做了太多的事情，而不是委托给其他的对象去处理
    当控制器掌握了太多的系统信
    导致：低内聚 Low cohesion — 做事不专注，做了太多的事 
    
    臃肿控制器的解决方法
         增加更多的控制器
         采用会话控制器替换外观控制器
         控制器委托任务给别的对象，而不是自己做 
         高内聚的理念
### High Cohesion 高内聚
##### 解决的问题：
    如何使对象功能专注、可理解、可管理，同时又支持 低耦合？
##### 解决方式：
    分配职责时保证高内聚
##### 用法：
    用作评价工具
    更多的是一种理念，没有具体的可操作原则
##### 衡量概念之间相关度的两个指标
    Cohesion，内聚：模块内元素之间联系紧密的程度，比如，一个类内部的操作之间
    Coupling，耦合：两个模块之间联系的强度
##### 内聚的“最佳实践”
    一个对象完成的功能不要太多
    这些功能都是同一类别的
##### 类低内聚的具有症状
    做了许多相互无关的工作
    做了太多工作 
##### 类低内聚的的原因
    大粒度的抽象
    做了太多本应该委托给其他类去做的工作
##### 类低内聚的问题
    难以理解 Hard to understand
    难以重用 Hard to reuse
    难以维护 Hard to maintain
    没有稳定的时刻，总是在修改 (通常都会高耦合)
#####高内聚的类
    有较少数量的操作，操作的性质基本一致，不会做太多的事情
    如果同类别的工作太多，则会定义新的类分担任务，相互间合作
    易于维护
    易于理解
    易于重用
    高内聚也是一种评估性原则，用于评估所有的设计决策是否合适
### PolyMorphism 多态
#####解决的问题：
    如何处理依据类型不同而有 不同行为的一类需求
##### 解决方法：
    使用多态操作为依据类型变化的行为 进行职责分配
    多态：
        不要去测试对象的类型或者条件逻辑，并以此选择相应的行为
        即，不要使用条件逻辑，而是为不同的类定义相同名字的方法
        不同的类实现了相同的接口、或者有一个共同的父类（继承）
### Pure Fabrication 纯虚构
##### 解决的问题：
       依据一些原则（比如，信息专家）获得的解决方案不合适的情况下，
    既不想违反低耦合、高内聚，也不想违反其他的原则，如何把职责分配给对象？ 
##### 解决方式：
    把高度内聚的职责分配给虚构出来的一个类，这个类在领域模型里没有对应的概念
    
    这种方式在有的场合能起到支持低耦合、高内聚、重用的效果
##### 应用纯虚构原则
    应设计具有很高的重复使用潜力的纯虚构
        责任必须保持小和有凝聚力
        再利用的潜力应增加
     许多现有的 GOF 模式是纯虚构的例子
    多数情况下是按功能类定义新的类，所以，是一种“功能为中心的”对象
##### 风险 
    宽泛地说，虚构对象分为两类
        代表性概念为主的分解
        行为性概念为主的分解
    可能导致面向功能或者面向过程的分析/设计，然后用OO语言去实现
### Indirection 间接
##### 解决的问题：
    把职责分配到哪里可以避免两个或者多个对象之间的 直接耦合？如何解耦对象以保持较高的可重用性？
##### 解决方式：
    把职责分配给一个中介对象，隔离对象与其他构件或 者服务，使它们不产生直接耦合
        因为中介对象是一种特殊的作用，一般对象与中间对象之间的直接耦合， 相对比较简单
### Protected Variations 隔离变化
##### 解决的问题：
     如何设计对象、系统和子系统，使得这些成分里面的变化因素、 
     不稳定因素不会对系统的其余部分造成意想不到的影响？
##### 解决方式：
     标识出能够预计的变化点或者不稳定点，职责分配的时候创建一 个稳定的接口，
     把它们与系统的其余部分隔离开来 
     
      “隔离可能的变化”是一个设计原则，它鼓励使用一个稳定的接口来封装可以 预知的变更点。
      以下技巧都使用了PV 
         数据封装 、多态 、数据-驱动设计， 服务查询，配置文件、接口 
### 开闭原则
#####设计变坏的前兆
    僵硬性 Rigidity 
        难以更改代码 
        从管理角度，拒绝任何的变化成为一种制度 
    易碎性 Fragility 
        即使是小小的改动也会导致级联性的后果的 
        代码在意想不到的地方终止
    固定性 
        代码纠缠在一起根本不可能重用
    黏滞性
        宁愿重新编写也不愿意修改 
#####设计变坏的原因
    需求不停地变化
        这是不可避免的
    设计的问题：“依赖管理”失衡 
        导致高耦合、低内聚

    软件系统在其生命周期都在发生变化
        无论是好的设计还是坏的设计，都面临着这个问题 
        但好的设计是稳定的
#####开-闭原则 
    软件系统应当允许功能扩展(即开放性）
    但是不允许修改原有的代码（即关闭性）
    
    遵循开-闭原则的模块符合下列准则 
        可以扩展行为以满足新的需求 
        但不允许修改模块的源代码
##### OCP（开闭原则）的启发
    1）定义所有的对象 - 数据为私有的 
    2）不要使用全局变量 
    
    修改公有的数据，经常冒着“打开”模块的风险
        它们常常会引起涟漪效应，导致许多地方连锁修改
        很难找全出错的地方并修改，一处修改会导致多处又出问题
##### OCP的理念
    OCP解决软件的僵硬性和易碎性
    我们应当尝试设计永远不需要修改的模块
    系统行为的扩展只需要增加新的代码，不能修改已有的代码
    模块不允许修改已有的代码，而这种修改会影响客户端 
### 能用组合的地方，不要用继承
    在OO技术里，有两种基本类型的代码重用: 组合、继承 
#####  继承的特点
     类的继承
        子类获得父系“全部功能”，“稍微”调整一下，比如覆盖实现几个方法 
            既快又容易
            代码实现时明确展示，由编程语言加以支持
        继承存在的副作用
            继承打破了封装性
            导致父类与子类之间高度耦合
            继承的代码是静态/编译-时绑定的
            客户需要购买整个软件包 
            父类定义了许多硬性的规定
                父类用了列表数据结构，而子类最好是用树结构
                子类经常直接使用Public和Protected数据成员，一旦父类修改了这些数据，将会影 响全体子类
                不得不了解父类的代码以求真正理解（相比组合，只要了解接口）
             
            关于类的继承
                可以使用继承，但设计师必须确信使用继承是很好的解决方案时才使用
                以泛化层次的方式，对概念进行建模
                    不是角色
                    不是行为
                    不能随意
##### 组合的特点
    对象组合
        没有打破封装性
        对象组合是一种动态/运行时绑定
            在运行时切换对象引用，就可以改变行为
        整体与部分之间只有接口边界关联，耦合较低
            对私有数据不存在“窥视与拨弄”
            不存在大量无用代码一类的负担 
        各部分的职责明确
            每个对象清晰地集中在少量的任务上
                 容易理解、容易维护
            只要阅读接口，就可以了解系统（至少理论上是如此）
            容易独立测试
                使用得当，将导致更可靠的设计
            每个类依然“苗条”
                避免的“巨无霸”这种反模式的现象，即一个类似乎完成了几乎全部的功能…
                重用的概率大增！ 
### 依赖倒置原则DIP
    I. 高层模块不应当依赖低层模块 ，两者都依赖抽象
    II.抽象不能依赖细节，细节应当依赖抽象
    
    引导
        继承层次关系中，基类不应当知道任何子类
        不能依赖一个有详细实现的模块，而这个模块本身也应当依赖抽象
        OCP宣扬了目标，DIP宣扬了机制
##### 为什么依赖倒置原则DIP
     传统的面向过程的程序设计，以功能划分系统
         高层模块是业务/应用规则 
         低层模块是对这些规则的实现 
         高层模块完全依赖调用低层模块提供的功能来完成自己的功能 
     因此，高层依赖底层
##### 启发
    面向接口设计，而不是面向实现设计
    使用继承，避免类之间的直接绑定
    
    为什么面向接口设计
        抽象类/接口修改的概率偏低 
        抽象概念容纳的范围广，易于扩展/修改 
        不应当修改代表抽象的类/接口，符合OCP原则
    
    避免传递性依赖
    每当有疑虑时，增加一个间接层
    
##### 例外情况
    有些类非常成熟、稳定
    插入抽象层，好处不多了，例如 String class，这里就可以直接使用具体类 


